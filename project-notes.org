* Crab News
:PROPERTIES:
:CUSTOM_ID: crab-news
:END:
sketchpad for this project. notes, they come and go.

** Elm vs Crux Terms
:PROPERTIES:
:CUSTOM_ID: elm-vs-crux-terms
:END:
- to help wrap my head around it

| Elm          | Crux                          | Notes                                                                         |
|--------------+-------------------------------+-------------------------------------------------------------------------------|
| Model        | Model                         | the Model holds all the possible states the app can be in                     |
| a) View      | ViewModel                     | the ViewModel contains data relevant to what the user sees *right now*        |
| b) View      | fn view in App                | the view() function populates ViewModel's data fron the Modul                 |
| c) View      | no Model -> Html Msg here     | the Shells will send/receive the data to/from ViewModel via Capabilities      |
| Update       | fn update in App              | (&self, msg: Self::Event, model: &mut Self::Model, caps: &Self::Capabilities) |
| Msg          | Events (accepts params?)      | an Event is all the possible things the user can do                           |
| (Model, Msg) | fn update implicit return of? | self.update(Event::Update(count), model, caps);                               |
| main         | crux_core::App entry point    | is an implementation of the App trait, exposed via the Core or Bridge         |
| a) init      | â€‹#[derive(Default)]           | set Model initial state with [[https://doc.rust-lang.org/std/default/trait.Default.html][Default]] Trait; impl Dewault for any custom Types |
| b) init      | no explicit Cmd               | no request effects during init. You can always add Event::Init if needed      |

--------------

| Side Effects    | Capabilities/FFI | Notes                                                                                   |
|-----------------+------------------+-----------------------------------------------------------------------------------------|
| a) Side Effects | Capabilities     | Crux has three types of effects: notifications, requests, and subscriptions             |
| b) Side Effects | Capabilities     | Crux side effects differ by the number of expected responses from the Shell             |
| Cmd Msg         | Capabilities     | from the perspective of the Shell, they are data oriented messages sent back and forth  |
| Cmd.none?       | Capabilities     | the Crux app will send the data to the Shell every time you call caps.render.render();  |
| subscriptions   | Capabilities     | subscriptions is a type of an effect in Crux, requested via capabilities                |
| ports           | Capabilities     | Contrary to Elm Ports, Crux requests all side-effects, internally, through Capabilities |
| flags           | Event::Configure | favor something like Event::Configure to take the configuration options                 |

** Model
:PROPERTIES:
:CUSTOM_ID: model
:END:
The Model is an overall state (and the only place for state) of your
application, it will hold all the loaded data, and any other kind of in-memory
cached things. Everything that needs to live for longer than single run of
`update` goes in the Model.

#+begin_src rust
#[derive(Default, Serialize)]
pub struct Model {
    theme: Theme,
    text_size: TextSize,
    accounts: Vec<Account>, // this should use the variant
    subscriptions: Vec<Subscription>,
    refresh_interval: RefreshInterval,
    open_method: OpeningMethod,
    use_browser: Browser,
    feeds: Vec<Feed>,
    feed_store: FeedStore,
    feed_view: FeedView,
    entries: Vec<Entry>,
    entry_read: ReadStatus,
    entry_star: StarStatus,
    content: Option<Content>,
}
#+end_src

** ViewModel
:PROPERTIES:
:CUSTOM_ID: viewmodel
:END:
the ViewModel is a straight "projection" of the Model -- it's calculated from it
  (with the view function)

#+begin_src rust
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ViewModel {
}
#+end_src

** Types
:PROPERTIES:
:CUSTOM_ID: types
:END:
*** Theme
:PROPERTIES:
:CUSTOM_ID: theme
:END:
#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum Theme {
    #[default]
    System,
    Light,
    Dark,
}
#+end_src

*** TextSize
:PROPERTIES:
:CUSTOM_ID: textsize
:END:
#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum TextSize {
    Small,
    #[default]
    Medium,
    Large,
    XLarge,
    XXLarge,
}
#+end_src

*** Account
:PROPERTIES:
:CUSTOM_ID: account
:END:
- Do I need a crate here? Does Crux provide native integration?
- Likely needing to code my own Capability for this one?
- Probably best left for a future version?

#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub struct Account {
    type: AccountType, // also unique ID
    subscriptions: Vec<Subscription>, // does it belong here instead?
}

#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum AccountType {
    // the variant is for the Model
    // the string is for ViewModel -> Shells -> UI account name display (and database?)
    // how do I check for variants Auth state in one go? impl? Capabilities?
    #[default]
    Local(None) = "Local",
    Apple(Option<Token>) = "iCloud",
    Google(Option<Token>) = "Google",
    Microsoft(Option<Token>) = "Nicrosoft",
    Canonical(Option<Token>) = "Ubuntu One",
    Dropbox(Option<Token>) = "Dropbox",
    // possibly more
}
#+end_src

*** Subscriptions
:PROPERTIES:
:CUSTOM_ID: subscriptions
:END:
- import/export fn of OPML file
- crate: [[https://crates.io/crates/opml]]

@1 Subscription

#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
// this should hold all OPML data for import/export, parse and read/write needed types from/to Feed
pub struct Subscription {
    pub id: String,
    pub feed_type: FeedType,
    pub title: Option<Text>,
    pub text: Option<Text>,
    pub description: Option<Text>,
    pub links: Vec<Link>,
}
#+end_src

@2 Example OPML

#+begin_src xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<opml version="2.0">
  <head>
    <title>mySubscriptions.opml</title>
    <dateCreated>Sat, 18 Jun 2005 12:11:52 GMT</dateCreated>
    <ownerName>Crab News</ownerName>
  </head>
  <body>
     <outline text="Gentle Wash Records" title="Gentle Wash Records" description="" type="rss" version="RSS" htmlUrl="https://gentlewashrecords.com/" xmlUrl="https://gentlewashrecords.com/atom.xml"/>
  </body>
</opml>
#+end_src

@3 OPML

#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub struct OPML {
    pub version: String,
    pub head: Option<Head>,
    pub body: Body,
}

#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub struct Head {
    pub title: Option<String>,
    pub date_created: Option<String>,
    pub date_modified: Option<String>,
    pub owner_name: Option<String>,
    pub owner_email: Option<String>,
    pub owner_id: Option<String>,
    pub docs: Option<String>,
    pub expansion_state: Option<String>,
    pub vert_scroll_state: Option<i32>,
    pub window_top: Option<i32>,
    pub window_left: Option<i32>,
    pub window_bottom: Option<i32>,
    pub window_right: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub struct Body {
    pub outlines: Vec<Outline>,
}

#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub struct Outline {
    pub text: String,
    pub type: Option<String>,
    pub is_comment: Option<bool>,
    pub is_breakpoint: Option<bool>,
    pub created: Option<String>,
    pub category: Option<String>,
    pub outlines: Vec<Outline>,
    pub xml_url: Option<String>,
    pub description: Option<String>,
    pub html_url: Option<String>,
    pub language: Option<String>,
    pub title: Option<String>,
    pub version: Option<String>,
    pub url: Option<String>,
}
#+end_src

*** RefreshInterval
:PROPERTIES:
:CUSTOM_ID: refreshinterval
:END:
#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum RefreshInterval {
    MinFifteen = {name: "15 minutes", time: 15},
    #[default]
    MinThirthy = {name: "30 minutes", time: 30},
    HoursOne = {name: "1 hour", time: 60},
    HoursTwo = {name: "2 hours", time: 120},
    HoursFour = {name: "4 hours", time: 240},
    HoursEight = {name: "8 hours", time: 480},
}
#+end_src

*** OpeningMethod
:PROPERTIES:
:CUSTOM_ID: openingmethod
:END:
#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum OpeningMethod {
    #[default]
    Background,
    Foreground,
}
#+end_src

*** Browser
:PROPERTIES:
:CUSTOM_ID: browser
:END:
#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum Browser {
    #[default]
    Default,
    Safari,
    Firefox,
    Brave,
    Chrome,
    Opera,
    Edge,
}
#+end_src

*** Feeds
:PROPERTIES:
:CUSTOM_ID: feeds
:END:
- crate: [[https://crates.io/crates/feed-rs]]

#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub struct Feed {
    pub feed_type: FeedType,
    pub id: String,
    pub title: Option<Text>,
    pub updated: Option<DateTime<Utc>>,
    pub authors: Vec<Person>,
    pub description: Option<Text>,
    pub links: Vec<Link>,
    pub categories: Vec<Category>,
    pub contributors: Vec<Person>,
    pub generator: Option<Generator>,
    pub icon: Option<Image>,
    pub language: Option<String>,
    pub logo: Option<Image>,
    pub published: Option<DateTime<Utc>>,
    pub rating: Option<MediaRating>,
    pub rights: Option<Text>,
    pub ttl: Option<u32>,
    pub entries: Vec<Entry>,
}

#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub struct Entry {
    pub id: String,
    pub title: Option<Text>,
    pub updated: Option<DateTime<Utc>>,
    pub authors: Vec<Person>,
    pub content: Option<Content>,
    pub links: Vec<Link>,
    pub summary: Option<Text>,
    pub categories: Vec<Category>,
    pub contributors: Vec<Person>,
    pub published: Option<DateTime<Utc>>,
    pub source: Option<String>,
    pub rights: Option<Text>,
    pub media: Vec<MediaObject>,
    pub language: Option<String>,
    pub base: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub struct Content {
    pub body: Option<String>,
    pub content_type: MediaTypeBuf,
    pub length: Option<u64>,
    pub src: Option<Link>,
}
#+end_src

*** FeedStore
:PROPERTIES:
:CUSTOM_ID: feedstore
:END:
#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum FeedStore {
    #[default]
    Root,
    Folder,
}
#+end_src

*** FeedView
:PROPERTIES:
:CUSTOM_ID: feedview
:END:
#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum FeedView {
    Today,
    #[default]
    Unread,
    Starred,
    Folder,
    Feed,
}
#+end_src

*** ReadStatus
:PROPERTIES:
:CUSTOM_ID: readstatus
:END:
#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum ReadStatus {
    Read,
    #[default]
    Unread,
}
#+end_src

*** StarStatus
:PROPERTIES:
:CUSTOM_ID: starstatus
:END:
#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum StarStatus {
    Starred,
    #[default]
    Unstarred,
}
#+end_src

** Database
:PROPERTIES:
:CUSTOM_ID: database
:END:
- Almost all data eventually goes into the db. adding as I go.
- crate: [[https://crates.io/crates/surrealdb]]
- embed: [[https://surrealdb.com/docs/surrealdb/embedding/rust]]

** Events
:PROPERTIES:
:CUSTOM_ID: events
:END:
#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
pub enum Event {
    // events from the shell
    SubsImport,
    SubsExport,
    SubsRefresh,
    SetSubsRefreshRate,
    DirAdd Account,
    DirDel Account,
    DirRename Account,
    FeedStore,
    FeedAdd,
    FeedDel,
    FeedMove,
    FeedRename,
    FeedRead,
    FeedUnread,
    FeedStar,
    FeedUnstar,
    EntryOpen Browser Method,
    ...

    // events local to the core
    #[serde(skip)]
    Fetch(crux_http::Result<crux_http::Response<Feed>, Box<dyn Error>>),
    ...
}
#+end_src
