* Crab News
:PROPERTIES:
:CUSTOM_ID: crab-news
:END:
sketchpad for this project. notes, they come and go.

- [[https://doc.rust-lang.org/std/collections/index.html][When Should You Use Which Collection?]]

  #+begin_quote
  To get this out of the way: you should probably just use Vec or
  HashMap. These two collections cover most use cases for generic data
  storage and processing. They are exceptionally good at doing what they
  do. All the other collections in the standard library have specific
  use cases where they are the optimal choice, but these cases are
  borderline niche in comparison. Even when Vec and HashMap are
  technically suboptimal, they're probably a good enough choice to get
  started.
  #+end_quote

- The =pub struct ViewModel {=} exposes its data via =pub=. Is this an Adapter?

- All else have =pub struct {=} only. Is this a Port?

** Elm vs Crux
:PROPERTIES:
:CUSTOM_ID: elm-vs-crux
:END:
To help wrap my head around it, hereby collected their similarities and
differences.

- [[https://redbadger.github.io/crux/guide/elm_architecture.html]]

| Elm          | Crux                            | Notes                                                                         |
|--------------+---------------------------------+-------------------------------------------------------------------------------|
| Model        | Model                           | the Model holds all the possible states the app can be in                     |
| a) View      | ViewModel                       | the ViewModel contains data relevant to the currently displayed UI/view       |
| b) View      | fn view() in App                | the fn view() function populates ViewModel's data fron the Model              |
| c) View      | see "Cmd Msg" in Capabilities   | the Shells will send/receive the data to/from ViewModel via Capabilities      |
| d) View      | no Model -> Html Msg here       | unlike Elm, Crux doesn't render a View but sends data to Shells (see "c")     |
| Update       | fn update() in App              | takes Model, Events, Capabilities and changes Model by invoking Events        |
| a) Msg       | Events                          | are all the possible things the user can do                                   |
| b) Cmd Msg   | Events                          | invoke Capabilities and may also callback more Events                         |
| (Model, Msg) | fn update() implicit return of? | self.update(Event::Update(count), model, caps);                               |
| main         | crux_core::App entry point      | is an implementation of the App trait, exposed via the Core or Bridge         |
| a) init      | â€‹#[derive(Default)]             | set Model initial state with [[https://doc.rust-lang.org/std/default/trait.Default.html][Default]] Trait; impl Default for any custom Types |
| b) init      | works like Elm's sandbox        | no request effects during init. You can always add Event::Init if needed      |

- [[https://redbadger.github.io/crux/guide/capabilities.html]]

| Side Effects    | Capabilities/FFI | Notes                                                                                   |
|-----------------+------------------+-----------------------------------------------------------------------------------------|
| a) Side Effects | Capabilities     | Crux has three types of effects: notifications, requests, and subscriptions             |
| b) Side Effects | Capabilities     | Crux side effects differ by the number of expected responses from the Shell             |
| c) Side Effects | Capabilities     | Crux fn update() in App is the only Capabilities consumer, via Events                   |
| Cmd Msg         | Capabilities     | from the perspective of the Shell, they are data oriented messages sent back and forth  |
| Cmd.none?       | Capabilities     | the Crux app will send the data to the Shell every time you call caps.render.render();  |
| subscriptions   | Capabilities     | subscriptions is a type of an effect in Crux, requested via capabilities                |
| ports           | Capabilities     | contrary to Elm Ports, Crux requests all side-effects, internally, through Capabilities |
| flags           | Event::Configure | favor something like Event::Configure to take the configuration options                 |

** Model
:PROPERTIES:
:CUSTOM_ID: model
:END:
The Model is an overall state (and the only place for state) of your
application, it will hold all the loaded data, and any other kind of
in-memory cached things. Everything that needs to live for longer than
single run of `update()` goes in the Model.

- This needs some more love and thinking. It's a start though

#+begin_src rust
#[derive(Default, Serialize)]
pub struct Model {
    ////////////////////////////
    // preferences UI
    ////////////////////////////
    theme: Theme,
    text_size: TextSize,
    browser: Browser,
    open_method: OpeningMethod,
    refresh_interval: RefreshInterval,
    accounts: Vec<Account>, // contains subscriptions

    ////////////////////////////
    // nain UI
    ////////////////////////////
    // "specials"
    unread_count: u16,
    starred_count: u16, // isUnread && isStarred
    entry_read: ReadStatus,
    entry_star: StarStatus,
    feed_url: String,

    // left column
    feed_view: FeedView, // Smart View = today | all unread | starred | folder | feed
    // for any account,
    account_name: String, // extrapolated from account
    feed_store: FeedStore, // root or folder
    feeds: Vec<Feed>,
    feed_name: String,

    // middle column
    entries_title: String, // folder or feed
    entries: Vec<Entry>,
    entry_title: String,
    entry_line: String, // whatever fits from content 1st line
    entry_date: Date, // dd mm yyyy

    // right column
    content: Option<Content>,
    // body: Option<String>,
    // content_type: MediaTypeBuf,
    // length: Option<u64>,
    // src: Option<Link>,
}
#+end_src

** ViewModel
:PROPERTIES:
:CUSTOM_ID: viewmodel
:END:
the ViewModel is a straight "projection" of the Model -- it's calculated
from it (with the view function)

- This needs some more love and thinking. It's a start though

#+begin_src rust
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct ViewModel {
    ////////////////////////////
    // preferences UI
    ////////////////////////////
    pub theme: Theme,
    pub text_size: TextSize,
    pub use_browser: Browser,
    pub open_method: OpeningMethod,
    pub refresh_interval: RefreshInterval,
    pub accounts: Vec<Account>, // contains subscriptions

    ////////////////////////////
    // nain UI
    ////////////////////////////
    // "specials"
    pub unread_count: u16,
    pub starred_count: u16,
    pub entry_read: ReadStatus,
    pub entry_star: StarStatus,
    pub feed_url: String,

    // left column
    pub feed_view: FeedView, // Smart View: today | all unread | starred,
    // for any account,
    pub account_name: String, // extrapolated from account
    pub feed_store: FeedStore, // root or folder
    pub feed_name: String, // extrapolated from feed

    // middle column
    pub entries_title: String, // folder or feed
    pub entries: Vec<Entry>,
    pub entry_title: String,
    pub entry_line: String, // whatever fits from content 1st line
    pub entry_date: StarStatus, // dd mm yyyy

    // right column
    pub content: Option<Content>,

    ////////////////////////////
    // modals
    ////////////////////////////
    // subscribe modal
    feed_url: String,
    pub feed_name: String,
    pub feed_store: FeedStore,

    // delete feed/folder <T> modal
    pub app_logo: Image,
    pub del_title: String,
    pub del_what: String, // either feed_name or feed_store
    pub button_action: ,
}
#+end_src

** Preferences
:PROPERTIES:
:CUSTOM_ID: preferences
:END:
#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub struct Preferences {
    theme: Theme,
    text_size: TextSize,
    browser: Browser,
    open_method: OpeningMethod,
    refresh_interval: RefreshInterval,
    accounts: Vec<Account>, // contains subscriptions
}

#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum Theme {
    #[default]
    System,
    Light,
    Dark,
}

#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum TextSize {
    Small { desc: String, size: u8 },
    #[default]
    Medium { desc: String, size: u8 },
    Large { desc: String, size: u8 },
    ExtraLarge { desc: String, size: u8 },
}

#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum Browser {
    #[default]
    Default,
    Safari,
    Firefox,
    Brave,
    Chrome,
    Opera,
    Edge,
}

#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum OpeningMethod {
    #[default]
    Background,
    Foreground,
}

#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum RefreshInterval {
    MinFifteen { desc: String, time: u8 },
    #[default]
    MinThirthy { desc: String, time: u8 },
    HoursOne { desc: String, time: u8 },
    HoursTwo { desc: String, time: u8 },
    HoursFour { desc: String, time: u8 },
    HoursEight { desc: String, time: u8 },
}
#+end_src

** Account
:PROPERTIES:
:CUSTOM_ID: account
:END:
- Do I need a crate here? Does Crux provide native integration?
  - [[https://rclone.org]] is interesting
- Likely needing to code my own Capability for this one?
  - [[https://github.com/rust-lang/rust/issues/109381]]
  - [[https://developer.apple.com/documentation/uikit/documents_data_and_pasteboard/synchronizing_documents_in_the_icloud_environment]]
- Probably best left for a future version?

#+begin_quote
I don't think you need a crate here nor create a Capability. You can
implement all inside the crux app and probably the only use crux_http
and crux_kv (key value store) capabilities. You will use crux_http
to communicate to the account clouds and probably the crux_kv to store
the tokens locally. There are already examples on how to implement the
crux_http on Android, iOS and the Web, but, I don't remember seeing
any of the crux_kv shell implementations.
#+end_quote

#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
pub struct Account {
    acct: AccountType,
    subs: Vec<Subscription>,
}

#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum AccountType {
    #[default]
    Local(AccountLocal),
    Native(AccountNative),
    Cloud(AccountCloud),
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
pub enum AccountLocal {
    Local { name: String, auth: bool },
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
pub enum AccountNative {
    // how do I check for Auth? impl? Capabilities?
    Apple { name: String, auth: bool },
    Google { name: String, auth: bool },
    Microsoft { name: String, auth: bool },
    Canonical { name: String, auth: bool },
    // more?
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
pub enum AccountCloud {
    // https://rclone.org
    Dropbox { name: String, auth: bool },
    // more
}
#+end_src

** Subscriptions
:PROPERTIES:
:CUSTOM_ID: subscriptions
:END:
- crate: [[https://crates.io/crates/opml]]
- [[http://opml.org/spec2.opml]]
- http://outlinerhowto.opml.org
- import/export fn of OPML file

#+begin_src rust
// "OPML" would use a template holdimg OPML, Head, Body and then loop over all Outline(s) data for import/export
// "Subscriptions to/from Vec<Feed>" loop over Outline(s) -> parse and read/write needed types from/to Vec<Feed>
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub struct Subscription {
    pub id: String,
    pub feed_type: FeedType,
    pub title: Option<Text>,
    pub text: Option<Text>,
    pub description: Option<Text>,
    pub links: Vec<Link>,
}

pub struct OPML {
    pub version: String,
    pub head: Option<Head>,
    pub body: Body,
}

pub struct Head {
    pub title: Option<String>,
    pub date_created: Option<String>,
    pub date_modified: Option<String>,
    pub owner_name: Option<String>,
    pub owner_email: Option<String>,
    pub owner_id: Option<String>,
    pub docs: Option<String>,
    pub expansion_state: Option<String>,
    pub vert_scroll_state: Option<i32>,
    pub window_top: Option<i32>,
    pub window_left: Option<i32>,
    pub window_bottom: Option<i32>,
    pub window_right: Option<i32>,
}

pub struct Body {
    pub outlines: Vec<Outline>,
}

pub struct Outline {
    pub text: String,
    pub type: Option<String>,
    pub is_comment: Option<bool>,
    pub is_breakpoint: Option<bool>,
    pub created: Option<String>,
    pub category: Option<String>,
    pub outlines: Vec<Outline>,
    pub xml_url: Option<String>,
    pub description: Option<String>,
    pub html_url: Option<String>,
    pub language: Option<String>,
    pub title: Option<String>,
    pub version: Option<String>,
    pub url: Option<String>,
}
#+end_src

#+begin_src xml
<!-- Example OPML -->
<?xml version="1.0" encoding="ISO-8859-1"?>
<opml version="2.0">
  <head>
    <title>mySubscriptions.opml</title>
    <dateCreated>Sat, 18 Jun 2005 12:11:52 GMT</dateCreated>
    <ownerName>Crab News</ownerName>
  </head>
  <body>
     <outline text="Gentle Wash Records" title="Gentle Wash Records" description="" type="rss" version="RSS" htmlUrl="https://gentlewashrecords.com/" xmlUrl="https://gentlewashrecords.com/atom.xml"/>
  </body>
</opml>
#+end_src

** Feeds
:PROPERTIES:
:CUSTOM_ID: feeds
:END:
- crate: [[https://crates.io/crates/feed-rs]]
- [[https://datatracker.ietf.org/doc/html/rfc4287]]
- [[https://validator.w3.org/feed/docs/atom.html]]
- [[https://www.rssboard.org/rss-specification]]

#+begin_src rust
// what do I want in Feed?
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub struct Subscription {
}
#+end_src

*** Related to Feeds
:PROPERTIES:
:CUSTOM_ID: related-to-feeds
:END:
#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum FeedStore {
    #[default]
    Root(Path),
    Folder(Path),
}

#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum ReadStatus {
    Read,
    #[default]
    Unread,
}

#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum StarStatus {
    Starred,
    #[default]
    Unstarred,
}

#[derive(Serialize, Deserialize, Clone, Default, Debug, PartialEq, Eq)]
pub enum FeedView {
    Today,
    #[default]
    Unread,
    Starred,
    Folder,
    Feed,
}
#+end_src

** Events
:PROPERTIES:
:CUSTOM_ID: events
:END:
- all the events to start coding, more later?

#+begin_src rust
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
pub enum Event {
    // EVENTS FROM THE SHELL
    // ANCHOR: Preferences UI
    // General panel
    SetTheme,
    SetTextSize,
    SetBrowser,
    SetOpeningMethod,
    SetRefreshInterval,
    // Account panel
    AddAccount,
    DeleteAccount,
    // ANCHOR_END: Preferences UI

    // ANCHOR: Menu
    // Shell thingiemageebs better done in UI?
    // File // mostly system related
    // Edit // mostly system related
    // View
    SortEntriesBy, // newest | oldest
    GroupByFeed,
    CleanUpEntries,
    HideRead // entries | feeds
    HideUIItem // sidebar | toolbar
    // Go
    DisplayNextUnreadEntry,
    DisplayToday,
    DisplayAllUnread,
    DisplayStarred,
    // Article -> SEE Entries
    // ANCHOR_END: Mmenu

    // ANCHOR: Main UI
    // Subscriptions live in struct Account {}
    ImportSubscriptions, // shows up in Menu -> File
    ExportSubscriptions, // shows up in Menu -> File

    // FeedStore -> root + 1st level folder. no more
    AddNewFolder, // shows up in Menu -> File
    DeleteFolder,
    RenameFolder,

    // FeedView -> today | all unread | starred | folder | feed
    SetFeedView,

    // Feeds
    RefreshFeeds, // shows up in Menu -> File
    AddNewFeed, // account | root | folder // shows up in Menu -> File
    DeleteFeed,
    RenameFeed,
    MoveFeedToFolder, // location -> root | folder
    CopyFeedURL,
    CopyFeedHomeURL,
    OpenFeedHomeURL,

    // Entries
    MarkEntryAsRead, // shows up in Menu -> Article
    MarkEntryAsUnread, // shows up in Menu -> Article
    MarkAllEntriesAsRead, // shows up in Menu -> Article
    MarkAllEntriesAsUnread, // shows up in Menu -> Article
    MarkEntryAsStarred, // shows up in Menu -> Article
    MarkEntryAsUnstarred, // shows up in Menu -> Article
    OpenEntryInBrowser, // shows up in Menu -> Article
    CopyEntryURL,

    // Content has no Events associated but system ones

    // ANCHOR_END: Main UI

    // EVENTS LOCAL TO THE CORE
    #[serde(skip)]
    Fetch(crux_http::Result<crux_http::Response<Feed>, Box<dyn Error>>),
}
#+end_src

** Tests
:PROPERTIES:
:CUSTOM_ID: tests
:END:
#+begin_src rust
#[cfg(test)]
mod test {
    use super::*;
    use crux_core::{assert_effect, testing::AppTester};

    #[test]
    fn renders() {
        let app = AppTester::<Counter, _>::default();
        let mut model = Model::default();

        let update = app.update(Event::Reset, &mut model);

        // Check update asked us to `Render`
        assert_effect!(update, Effect::Render(_));
    }

    #[test]
    fn shows_initial_count() {
        let app = AppTester::<Counter, _>::default();
        let model = Model::default();

        let actual_view = app.view(&model).count;
        let expected_view = "Count is: 0";
        assert_eq!(actual_view, expected_view);
    }

    #[test]
    fn increments_count() {
        let app = AppTester::<Counter, _>::default();
        let mut model = Model::default();

        let update = app.update(Event::Increment, &mut model);

        let actual_view = app.view(&model).count;
        let expected_view = "Count is: 1";
        assert_eq!(actual_view, expected_view);

        // Check update asked us to `Render`
        assert_effect!(update, Effect::Render(_));
    }

    #[test]
    fn decrements_count() {
        let app = AppTester::<Counter, _>::default();
        let mut model = Model::default();

        let update = app.update(Event::Decrement, &mut model);

        let actual_view = app.view(&model).count;
        let expected_view = "Count is: -1";
        assert_eq!(actual_view, expected_view);

        // Check update asked us to `Render`
        assert_effect!(update, Effect::Render(_));
    }

    #[test]
    fn resets_count() {
        let app = AppTester::<Counter, _>::default();
        let mut model = Model::default();

        app.update(Event::Increment, &mut model);
        app.update(Event::Reset, &mut model);

        let actual_view = app.view(&model).count;
        let expected_view = "Count is: 0";
        assert_eq!(actual_view, expected_view);
    }

    #[test]
    fn counts_up_and_down() {
        let app = AppTester::<Counter, _>::default();
        let mut model = Model::default();

        app.update(Event::Increment, &mut model);
        app.update(Event::Reset, &mut model);
        app.update(Event::Decrement, &mut model);
        app.update(Event::Increment, &mut model);
        app.update(Event::Increment, &mut model);

        let actual_view = app.view(&model).count;
        let expected_view = "Count is: 1";
        assert_eq!(actual_view, expected_view);
    }
}
#+end_src
** Database
:PROPERTIES:
:CUSTOM_ID: database
:END:
- Almost all data eventually goes into the db. adding as I go.
- crate: [[https://crates.io/crates/surrealdb]]
- embed: [[https://surrealdb.com/docs/surrealdb/embedding/rust]]
